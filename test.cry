seq1 : [3][4]
seq1 = [0xf, 0x1, 0x8]

seq2 : [5][8]
seq2 = [0xff, 0xcc, 0x11, 0x22, 0x99]

ele1 : [4]
ele1 = seq1 @ 1

ele2 : [8]
ele2 = seq2 @ 3

// seq : [4]
// seq = 0xC

// ele : Bit
// ele = seq @ 2

// genericEncrypt : {a, b, c} (a -> b -> c) -> a -> b -> c
// genericEncrypt encryptFn key plaintext = encryptFn key plaintext

// modularAdd : {a} (fin a) => [a] -> [a] -> [a]
// modularAdd x y = x + y

// // Modular addition under a specific modulus
// modularAdd2 : {a} (fin a) => ([a], [a], [a]) -> [a] // (x, y, modulus)
// modularAdd2 (x, y, modulus) = (x + y) % modulus


// A function that reverses a generic sequence
// Generic reverse function definition
// reverse : {n, a} (fin n) => [n]a -> [n]a
// reverse xs = [xs @ i | i <- [n-1, n-2 .. 0]]
//   where n = length xs


// // Example usage
// myList : [5]Integer
// myList = [1, 2, 3, 4, 5]

// reversedList = reverse myList // This should give [5, 4, 3, 2, 1]

// // A function that takes a generic sequence and returns the same sequence with each element duplicated
// duplicateEach : {a, n} (fin n) => GenericSeq a n -> GenericSeq a (2 * n)
// duplicateEach xs = [xs @ (i / 2) | i <- [0 .. (2 * n) - 1]]


// reverse : {a} (fin n) => [n]a -> [n]a
// reverse xs = [xs @ i | i <- [(n-1), (n-2) .. 0]]

// seq1 : [5]Integer
// seq1 = [1, 2, 3, 4, 5]
// reversedSeq1 = reverse seq1  // This will be [5, 4, 3, 2, 1]

// seq2 : [4]Bit
// seq2 = [True, False, True, True]
// reversedSeq2 = reverse seq2  // This will be [True, True, False, True]

// type AlgorithmState = {counter : Integer, buffer : [64], flags : [8]} // A record type for the algorithm state

// initialState : AlgorithmState
// initialState = {counter = zero, buffer = zero, flags = zero} // Initializes all to zero

// updateState : AlgorithmState -> AlgorithmState
// updateState state =  { state |
//       counter = state.counter + 1, 
//       buffer = ~state.buffer, 
//       flags = zipWith (^) state.flags 0xf0
// }

// property CounterIncrement state = 
//     (updateState state).counter == state.counter + 1

// property BufferToggle state = 
//     (updateState (updateState state)).buffer == state.buffer

// property FlagsXOR state = 
//     (updateState state).flags == zipWith (^) state.flags 0xf0


// updateState : AlgorithmState -> AlgorithmState
// updateState state = {counter = state.counter + 1, buffer = ~state.buffer, flags = state.flags ^ [1, 1, 1, 1, 0, 0, 0, 0]}


// type AlgorithmState = {counter : IntegerBit, buffer : [64]Bit, flags : [8]Bit}
// initialState : AlgorithmState
// initialState = {counter = 0, buffer = replicate {False}, flags = replicate {False}}

// updateState : AlgorithmState -> AlgorithmState
// updateState state = {counter = state.counter + 1, buffer = ~state.buffer, flags = state.flags ^ [1, 1, 1, 1, 0, 0, 0, 0]}

// type MyRecord = {
//     field1 : Bit,
//     field2 : [3]Bit,
//     field3 : [4]Bit
// }

// myRecord : MyRecord
// myRecord = {
//     field1 = True,
//     field2 = [False, True, False],
//     field3 = [True, True, False, False]
// }

// first_field : Bit
// first_field = myRecord.field1 // Accessing the first field of the record

// second_field : [3]Bit
// second_field = myRecord.field2 // Accessing the second field of the record

// updatedRecord : MyRecord
// updatedRecord = myRecord{field2 = [True, True, True]} // Updating the second field

// type MyRecord = {field1 : Bit, field2 : [3], field3 : [4]}

// type NestedRecord = {nested : MyRecord, anotherField : [5]Bit}
// nestedRecord : NestedRecord
// nestedRecord = {nested = {field1 = False, field2 = [True, False, True], field3 = [False, False, False, True]}, anotherField = [True, True, True, False, False]}

// // toggleFirstBit : MyRecord -> MyRecord
// toggleFirstBit : MyRecord -> MyRecord
// toggleFirstBit record = record { field1 = ~record.field1 } // Function to toggle the first bit of a record


// // An example with a simple encryption scheme
// type Key = [8]Bit
// type State = [8]Bit
// type CipherText = [8]Bit

// encrypt : (Key, State) -> CipherText
// encrypt (key, state) = zipWith (^) key state // A simple XOR-based encryption

// property EncryptDecrypt = 
//     \(key : Key) (state : State) ->
//         (encrypt(key, encrypt(key, state))) == state

// // An example using tuples for algorithm state management
// type RoundKey = [8]Bit
// type RoundState = ([8]Bit, [8]Bit) // Tuple representing state for two rounds

// updateState : (RoundKey, RoundState) -> RoundState
// updateState (key, (state1, state2)) = 
//     (zipWith (^) key state1, zipWith (^) key state2) // Update both states

// property DoubleUpdate = 
//   \(key : RoundKey) (initialState : RoundState) ->
//      updateState(key, updateState(key, initialState)) == initialState



// // Example of XORing two sequences (common in many cryptographic algorithms)
// xor_sequences : [8]Bit -> [8]Bit -> [8]Bit
// xor_sequences seq1 seq2 = zipWith (^) seq1 seq2 // Element-wise XOR

// seqA : [8]Bit
// seqA = 0xAA

// seqB : [8]Bit
// seqB = 0x55

// result_seq : [8]Bit
// result_seq = xor_sequences seqA seqB // Result of XORing seqA and seqB

// // Splitting a sequence into blocks
// long_seq : [16]Bit // Similar to a block of data in cryptography
// long_seq = 0xAAAA

// blocks : [2][8]Bit // Splitting into two blocks of 8 bits
// blocks = split long_seq // There's no direct C equivalent

// joined_seq : [16]Bit
// joined_seq = join blocks

// // A simple bitwise NOT operation applied to a sequence
// negate_seq : [8]Bit -> [8]Bit
// negate_seq input = ~input // Bitwise NOT each element

// input_seq : [8]Bit
// input_seq = 0xCD

// negated_seq : [8]Bit
// negated_seq = negate_seq input_seq // Apply function, no direct equivalent in C

// a : Bit
// a = True

// b : Bit
// b = False

// // AND operation (similar to a && b in C)
// result_and : Bit
// result_and = a && b

// // OR operation (similar to a || b in C)
// result_or : Bit
// result_or = a || b

// // NOT operation (similar to !a in C)
// result_not : Bit
// result_not = ~a

// result_cond : Bit
// result_cond = if a then b else ~b

// // One-time pad encryption
// plaintext_bit : Bit
// plaintext_bit = True // Your plaintext

// key_bit : Bit
// key_bit = False // Your secret key

// encrypted_bit : Bit
// encrypted_bit = plaintext_bit ^ key_bit // XOR for encryption

// decrypted_bit : Bit
// decrypted_bit = encrypted_bit ^ key_bit // XOR for decryption (should equal plaintext_bit)