\chapter*{Introduction}

\section*{Overview}

Cryptol is a domain-specific language that has been engineered with a clear purpose: to aid in the specification, implementation, and verification of cryptographic algorithms. Originating from a need to describe cryptographic functions in a manner that is both precise and verifiable, Cryptol has evolved as a bridge between the abstract world of cryptographic theory and the concrete realm of implementation.

Unlike general-purpose programming languages, which are designed to be versatile and broad, Cryptol is finely tuned for a specific domain. It embodies the principles of functional programming, making it an exemplary tool for cryptographers who are more accustomed to mathematical functions than to traditional software engineering constructs.

\section*{Functional Programming in Cryptol}
Functional programming is a paradigm that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. Cryptol, inheriting this paradigm, allows developers to write code that closely resembles the mathematical definitions of cryptographic algorithms.

\subsection*{Pure Functions}
At the heart of functional programming—and consequently at the core of Cryptol—are pure functions. These functions, which provide the same output for the same input every time, are devoid of side effects, ensuring predictability and ease of formal verification. In Cryptol, this principle allows for the straightforward expression of cryptographic transformations.

\subsection*{Immutability}
Cryptol espouses the functional programming principle of immutability. Once data is created, it cannot be altered, mirroring the immutable nature of data in cryptographic processes. This property simplifies reasoning about the behavior of cryptographic algorithms and enhances the reliability and security of their implementations.

\subsection*{Type System and Type Inference}
Cryptol's type system is robust and expressive, facilitating the prevention of common bugs found in cryptographic software. Types in Cryptol are not just annotations but are an integral part of the language's semantics, enforcing the correct usage of cryptographic constructs. Furthermore, Cryptol's type inference mechanism reduces the verbosity of code, making algorithms concise and less prone to error.

\subsection*{Higher-order Functions and Currying}
Cryptol supports higher-order functions, a hallmark of functional programming. These are functions that can take other functions as inputs or return them as outputs. This feature enables cryptographers to construct higher-level abstractions and compose algorithms elegantly. Additionally, Cryptol utilizes currying, allowing partial application of functions and further contributing to the language's expressiveness and flexibility.

\section*{Coding Style in Cryptol}
The coding style in Cryptol is distinct and aligned with its functional nature. Developers are encouraged to write clear, concise, and mathematically-oriented code. The style promotes readability and maintainability, crucial for the complex and sensitive nature of cryptographic software.

\subsection*{Clarity and Conciseness}
Cryptol code should be as clear and concise as possible, mirroring mathematical definitions. This clarity is achieved through the use of descriptive identifiers, minimal use of side effects, and leveraging Cryptol's powerful type system.

\subsection*{Modularization and Reuse}
Cryptol encourages modularization and the reuse of code. Functions and types should be defined in a modular manner, allowing them to be easily reused across different cryptographic algorithms and protocols.

\subsection*{Testing and Verification}
Given the critical nature of cryptographic software, testing and formal verification are integral parts of the Cryptol workflow. The language provides facilities for both property-based testing and formal verification, enabling developers to rigorously test and prove properties about their code.


Cryptol stands at the intersection of cryptography and functional programming. Its design philosophy, rooted in the principles of functional programming, makes it an ideal tool for specifying, implementing, and verifying cryptographic algorithms. By understanding and embracing the functional aspects and coding style of Cryptol, developers and cryptographers can create more secure, reliable, and verifiable cryptographic software.

\section*{Key Features}
\begin{itemize}
	\item \textbf{Mathematical Notation:} Cryptol's syntax closely mirrors the mathematical notation used in cryptography, making algorithms more readable and understandable.
	\item \textbf{Formal Verification:} Allows for the formal verification of algorithm properties, ensuring that they comply with their specifications.
	\item \textbf{Type System:} Features a strong, static type system that prevents many common errors in cryptographic implementations.
	\item \textbf{Abstraction:} Supports high levels of abstraction, enabling cryptographers to focus on algorithmic design rather than implementation details.
\end{itemize}

\section*{Applications}
Cryptol is widely used in academic and industrial settings for:
\begin{itemize}
	\item Specifying cryptographic algorithms.
	\item Testing and verifying the correctness of cryptographic implementations.
	\item Educating new cryptographers about algorithm design and analysis.
\end{itemize}

\chapter{A Crash Course in Cryptol}

%======= Sec: Basic Data Types ======%
\section{Basic Data Types}

%%%==== Subsec: Bit ====%%%
\subsection{Bit: Booleans}
\begin{quote}\bf
	``The most basic data type in Cryptol, representing a single binary digit (0 or 1).''
\end{quote}

%%%%%== Subsubsec: Bit I ==%%%%%
\subsubsection{Basic Bit Operations}

\begin{tcolorbox}[colframe=defcolor,title={\color{white}\bf Data Type: \texttt{Bit}}]
In Cryptol, a `\texttt{Bit}` can either be \begin{center}
`\texttt{True}' (equivalent to 1 in C)\quad or\quad `\texttt{False}' (equivalent to 0 in C).
\end{center}
\end{tcolorbox}

\begin{lstlisting}[style=cryptol]
a : Bit
a = True

b : Bit
b = False
\end{lstlisting}

\noindent Similar to C, Cryptol supports logical operations like \textbf{AND}, \textbf{OR}, and \textbf{NOT}.
\begin{lstlisting}[style=cryptol]
// AND operation (similar to a & b in C)
result_and : Bit
result_and = a && b

// OR operation (similar to a | b in C)
result_or : Bit
result_or = a || b

// NOT operation (similar to !a in C)
result_not : Bit
result_not = ~a
\end{lstlisting}

\begin{lstlisting}[style=zsh]
$ Main> result_and
False
$ Main> result_or
True
$ Main> result_not
False 
\end{lstlisting}

%%%%%== Subsubsec: Bit II ==%%%%%
\subsubsection{Intermediate Bit Operations}

\textbf{Conditional Expressions:} Cryptol uses the `\textbf{if...then...else}' syntax, which is similar to the ternary operator `\textbf{?:}' in C.

\begin{lstlisting}[style=cryptol]
// Conditional expression (similar to a ? b : c in C)
result_cond : Bit
result_cond = if a then b else ~b
\end{lstlisting}

\textbf{XOR Operation}: This is commonly used in cryptography for things like one-time pads.

\begin{lstlisting}[style=cryptol]
// XOR operation
c : Bit
c = True // Assuming some value

result_xor : Bit
result_xor = a ^ c // Similar to a ^ c in C
\end{lstlisting}


%%%%%== Subsubsec: Bit III ==%%%%%
\subsubsection{Advanced Cryptographic Applications with Bit}
\textbf{Simple Cryptographic Operation:} Here’s a very basic example of a cryptographic operation in Cryptol, a one-time pad encryption of a single bit. In practical applications, you'll work with sequences or arrays of bits.

\begin{lstlisting}[style=cryptol]
// One-time pad encryption
plaintext_bit : Bit
plaintext_bit = True // Your plaintext

key_bit : Bit
key_bit = False // Your secret key

// XOR for encryption
encrypted_bit : Bit
encrypted_bit = plaintext_bit ^ key_bit

// XOR for decryption (should equal plaintext_bit)
decrypted_bit : Bit
decrypted_bit = encrypted_bit ^ key_bit           
\end{lstlisting}

\begin{lstlisting}[style=cryptol]
module XOR where

// Defines an XOR function for two bits
xor : Bit -> Bit -> Bit
xor a b = (a || b) && ~(a && b)

// Property: XOR is its own inverse
property xor_inverse a b = xor (xor a b) b == a
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ cryptol XOR.cry
version 2.8.0

Loading module Cryptol
Loading module XOR
$ XOR> :prove xor_inverse
Q.E.D.
(Total Elapsed Time: 0.008s, using Z3)
\end{lstlisting}

\newpage
%%%==== Subsec: Sequence ====%%%
\subsection{Sequences: Homogeneous Collections}
\begin{quote}\bf
``Fixed-length, ordered collections of elements, which can be bits or other types.''
\end{quote}

%%%%%== Subsubsec: Sequence I ==%%%%%
\subsubsection{Basic Sequence Operations}
\begin{tcolorbox}[colframe=defcolor,title={\color{white}\bf Sequence}]
In Cryptol, a \textbf{sequence} is defined with square brackets. $\texttt{[, , ,]}$.
\end{tcolorbox}
\begin{remark}
Unlike C, where you typically define the array size and type, Cryptol infers these from the context.
\end{remark}
\begin{lstlisting}[style=cryptol]
seq : [4]Bit // A sequence of 4 bits
seq = [True, False, True, False] // Equivalent to 0b1010
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> seq
0xa
\end{lstlisting}
\vspace{16pt}
\textbf{Accessing Elements:} Accessing sequence elements is similar to accessing array elements in C.
\begin{lstlisting}[style=cryptol]
element1 : Bit
element1 = seq @ 0 // Accessing the first element, similar to seq[0] in C

element3 : Bit
element3 = seq @ 3
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> element1
True
$ Main> element3
False
\end{lstlisting}

%%%%%== Subsubsec: Sequence II ==%%%%%
\subsubsection{Intermediate Sequence Operations}
\textbf{Sequence Concatenation:} You can concatenate sequences to form longer sequences.
\begin{lstlisting}[style=cryptol]
seq1 : [3]Bit
seq1 = [True, True, False] // Similar to {1, 1, 0} in C

seq2 : [5]Bit
seq2 = [False, True, True, False, True] // Similar to {0, 1, 1, 0, 1} in C

// Concatenating two sequences 0b 110 01101 = 0b 1100 1101
combined_seq : [8]Bit
combined_seq = seq1 # seq2
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> seq1
0x6
$ Main> seq2
0x0d
$ Main> combined_seq
0xcd
\end{lstlisting}

\begin{lstlisting}[style=cryptol]
seq1 : [3][4]
seq1 = [0xf, 0x1, 0x8]

seq2 : [5][8]
seq2 = [0xff, 0xcc, 0x11, 0x22, 0x99]

ele1 : [4]
ele1 = seq1 @ 1

ele2 : [8]
ele2 = seq2 @ 3
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> seq1
[0xf, 0x1, 0x8]
$ Main> ele1
0x1
$Main> seq2
[0xff, 0xcc, 0x11, 0x22, 0x99]
$ Main> ele2
0x22
\end{lstlisting}

%%%%%== Subsubsec: Sequence III ==%%%%%
\subsubsection{Advanced Cryptographic Applications with Sequence}
\textbf{Block Operations:} In cryptography, you often work with blocks of data. In Cryptol, you can easily split sequences into blocks or combine blocks into a single sequence.
\begin{lstlisting}[style=cryptol]
// Splitting a sequence into blocks
long_seq : [16]Bit // Similar to a block of data in cryptography
long_seq = 0xAAAA

blocks : [2][8]Bit // Splitting into two blocks of 8 bits
blocks = split long_seq // There's no direct C equivalent

joined_seq : [16]Bit
joined_seq = join blocks
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> long_seq
0xaaaa
$ Main> blocks
[0xaa, 0xaa]
$ Main> joined_seq
0xaaaa
\end{lstlisting}
\vspace{16pt}
\textbf{Applying Functions to Sequences:} In Cryptol, you can apply functions to entire sequences, which is useful for cryptographic transformations.
\begin{lstlisting}[style=cryptol]
// A simple bitwise NOT operation applied to a sequence
negate_seq : [8]Bit -> [8]Bit
negate_seq input = ~input // Bitwise NOT each element

input_seq : [8]Bit
input_seq = 0xCD // ~ 0b11001101 = 0b00110010 = 0x32

negated_seq : [8]Bit
negated_seq = negate_seq input_seq
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> negate_seq
<function>
$ Main> input_seq
0xcd
$ Main> negated_seq
0x32
\end{lstlisting}
\vspace{16pt}
\newpage
\noindent\textbf{Advanced Cryptographic Patterns:} Sequences are used in various cryptographic algorithms, such as block ciphers and hash functions, to handle data in structured formats.
\begin{lstlisting}[style=cryptol]
// Example of XORing two sequences (common in many cryptographic algorithms)
xor_sequences : [8]Bit -> [8]Bit -> [8]Bit
xor_sequences seq1 seq2 = zipWith (^) seq1 seq2 // Element-wise XOR

seqA : [8]Bit
seqA = 0xAA

seqB : [8]Bit
seqB = 0x55

//   0b 1010 1010
// ^ 0b 0101 0101
//   0b 1111 1111
result_seq : [8]Bit
result_seq = xor_sequences seqA seqB // Result of XORing seqA and seqB
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> seqA
0xaa
$ Main> seqB
0x55
$ Main> result_seq
0xff
\end{lstlisting}
\begin{note}[`\texttt{zipWith}' in Haskell]
\ \begin{lstlisting}[style=haskell]
// [f(x1, y1), f(x2, y2), ..., f(x_n, y_n)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith f list1 list2
\end{lstlisting}
%\textbf{Example Translated to C:}\\
%In C, you don't have direct equivalents for all Haskell features due to Haskell's higher-level abstractions and strong type system. Here's an analogy using function pointers:
%\begin{lstlisting}[style=C]
%// Imagine 'a', 'b', and 'c' are all 'int' for simplicity
%void zipWith(int (*f)(int, int), 		// (a->b->c)
%			 int* list1, int* list2,	// [a], [b]
%			 int* result,				// [c]
%			 int length
%) {
%	for (int i = 0; i < length; i++) {
%		result[i] = f(list1[i], list2[i]);
%	}
%}
%\end{lstlisting}
\end{note}

%%%==== Subsec: Tuple ====%%%
\subsection{Tuples: Heterogeneous Collections}
\begin{quote}\bf
``Collections of possibly different types grouped together.''
\end{quote}

%%%%%== Subsubsec: Tuple I ==%%%%%
\subsubsection{Basic Tuple Operations}
\begin{tcolorbox}[colframe=defcolor,title={\color{white}\bf Tuple}]
A \textbf{tuple} can hold a fixed number of elements, which can be of different types.
\end{tcolorbox}
\begin{remark}
Unlike C, where you define a struct with named fields, Cryptol tuples are indexed by position.
\end{remark}
\begin{lstlisting}[style=cryptol]
// A tuple containing a Bit, a 3-Bit sequence, and a 4-Bit sequence
myTuple : (Bit, [3]Bit, [4]Bit)
myTuple = (True, [False, True, False], [True, True, False, False])
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> myTuple
(True, 0x2, 0xc)
\end{lstlisting}
\vspace{16pt}
\newpage
\noindent\textbf{Accessing Tuple Elements:} Elements in a tuple are accessed by their positions, starting from zero.
\begin{lstlisting}[style=cryptol]
first_element : Bit
first_element = myTuple.0 // Accessing the first element of the tuple

second_element : [3]Bit
second_element = myTuple.1 // Accessing the second element of the tuple
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> first_element
True
$ Main> second_element
0x2
\end{lstlisting}
\vspace{16pt}
\textbf{Updating Tuple Elements:} Unlike in C, where you might update an element directly, in Cryptol, you usually create a new tuple with the updated value due to its immutable nature.
\begin{lstlisting}[style=cryptol]
// Updating the second element
updatedTuple : (Bit, [3]Bit, [4]Bit)
updatedTuple = (myTuple.0, [True, True, True], myTuple.2)
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> updatedTuple
(True, 0x7, 0xc)
\end{lstlisting}

%%%%%== Subsubsec: Tuple II ==%%%%%
\subsubsection{Intermediate Tuple Operations}
\textbf{Tuple Decomposition:} You can decompose a tuple into its components, similar to unpacking a struct in C.
\begin{lstlisting}[style=cryptol]
// Decomposing the tuple into variables
(bitVal, threeBitSeq, fourBitSeq) = myTuple
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> bitVal
True
$ Main> threeBitSeq
0x2
$ Main> fourBitSeq
0xc
\end{lstlisting}
\vspace{16pt}
\textbf{Nested Tuples:} Tuples can contain other tuples, providing a way to structure complex data.
\begin{lstlisting}[style=cryptol]
// A tuple where the first element is also a tuple
nestedTuple : ((Bit, Bit), [4]Bit)
nestedTuple = ((True, False), [True, True, False, False])
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> nestedTuple
((True, False), 0xc)
\end{lstlisting}

\newpage
%%%%%== Subsubsec: Tuple III ==%%%%%
\subsubsection{Advanced Cryptographic Applications with Tuple}
\textbf{Using Tuples in Cryptographic Algorithms:} Tuples can represent structured data in cryptographic algorithms, like keys and states.
\begin{lstlisting}[style=cryptol]
// An example with a simple encryption scheme
type Key = [8]Bit
type State = [8]Bit
type CipherText = [8]Bit

encrypt : (Key, State) -> CipherText
encrypt (key, state) = zipWith (^) key state // A simple XOR-based encryption

property EncryptDecrypt = 
	\(key : Key) (state : State) ->
		(encrypt(key, encrypt(key, state))) == state
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> :prove 
:prove EncryptDecrypt
	Q.E.D.
(Total Elapsed Time: 0.012s, using Z3)
\end{lstlisting}
\vspace{16pt}
\textbf{Advanced Data Structuring:} In more complex cryptographic algorithms, you might use tuples to represent different parts of the algorithm's state, input, or output.
\begin{lstlisting}[style=cryptol]
// An example using tuples for algorithm state management
type RoundKey = [8]Bit;
type RoundState = ([8]Bit, [8]Bit); // Tuple representing state for two rounds

// Update both states
updateState : (RoundKey, RoundState) -> RoundState;
updateState (key, (state1, state2)) =
	(zipWith (^) key state1, zipWith (^) key state2);

property DoubleUpdate = 
	\(key : RoundKey) (initialState : RoundState) ->
		updateState(key, updateState(key, initialState)) == initialState
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> :prove 
:prove DoubleUpdate
	Q.E.D.
(Total Elapsed Time: 0.013s, using Z3)
\end{lstlisting}

\newpage
%%%==== Subsec: Records ====%%%
\subsection{Records: Named Collections}
\begin{quote}\bf
``Similar to tuples, but each element is identified by a name.''
\end{quote}

%%%%%== Subsubsec: Record I ==%%%%%
\subsubsection{Basic Record Operations}
\begin{tcolorbox}[colframe=defcolor,title={\color{white}\bf Record}]
In Cryptol, you define a record with braces `\texttt{$\{\}$}' and specify the names and types of its fields.
\end{tcolorbox}
\begin{lstlisting}[style=cryptol]
type MyRecord = {
	field1 : Bit,
	field2 : [3]Bit,
	field3 : [4]Bit
}

myRecord : MyRecord
myRecord = {
	field1 = True,
	field2 = [False, True, False],
	field3 = [True, True, False, False]
}

first_field : Bit
first_field = myRecord.field1 // Accessing the first field of the record

second_field : [3]Bit
second_field = myRecord.field2 // Accessing the second field of the record
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> myRecord
{field1 = True, field2 = 0x2, field3 = 0xc}
$ Main> first_field
True
$ Main> second_field
0x2
\end{lstlisting}

%%%%%== Subsubsec: Record II ==%%%%%
\subsubsection{Intermediate Record Operations}
\textbf{Nested Records:} Records can contain other records, which allows you to structure complex data hierarchically.
\begin{lstlisting}[style=cryptol]
type NestedRecord = {nested : MyRecord, anotherField : [5]Bit}
nestedRecord : NestedRecord
nestedRecord = {
	nested = {
		field1 = False,
		field2 = [True, False, True],
		field3 = [False, False, False, True]
	}, 
	anotherField = [True, True, True, False, False]
}
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> nestedRecord
{nested = {field1 = False, field2 = 0x5, field3 = 0x1},
	anotherField = 0x1c}
\end{lstlisting}

\newpage
%%%%%== Subsubsec: Record III ==%%%%%
\subsubsection{Advanced Cryptographic Applications with Record}
\textbf{Cryptographic Keys and Configurations:} Records are excellent for representing complex keys and configuration options in cryptographic algorithms.

\begin{lstlisting}[style=cryptol]
// A record type for encryption configuration
type CryptoConfig = {key : [128], iv : [128]} 

// An example configuration using all zeros (False)
defaultConfig : CryptoConfig
defaultConfig = {key = zero, iv = ~zero}
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> defaultConfig
{key = 0x00000000000000000000000000000000,
 iv = 0xffffffffffffffffffffffffffffffff}
\end{lstlisting}
\vspace{16pt}
\textbf{State Management in Cryptographic Algorithms:} Use records to manage the state of an algorithm, making it easier to handle multiple pieces of related data.
\begin{lstlisting}[style=cryptol]
type AlgorithmState = {counter : [32], buffer : [64], flags : [8]} // A record type for the algorithm state

initialState : AlgorithmState
initialState = {counter = zero, buffer = zero, flags = zero} // Initializes all to zero

updateState : AlgorithmState -> AlgorithmState
updateState state =  { state |
	counter = state.counter + 1, 
	buffer = ~state.buffer, 
	flags = zipWith (^) state.flags 0xf0
}
\end{lstlisting}

\begin{lstlisting}[style=cryptol]
property CounterIncrement state = 
	(updateState state).counter == state.counter + 1

property BufferToggle state = 
	(updateState (updateState state)).buffer == state.buffer

property FlagsXOR state = 
	(updateState state).flags == zipWith (^) state.flags 0xf0
\end{lstlisting}

\begin{lstlisting}[style=zsh]
$ Main> :prove
:prove CounterIncrement
Q.E.D.
(Total Elapsed Time: 0.013s, using Z3)
:prove BufferToggle
Q.E.D.
(Total Elapsed Time: 0.008s, using Z3)
:prove FlagsXOR
Q.E.D.
(Total Elapsed Time: 0.009s, using Z3)
\end{lstlisting}

\newpage
%%%==== Subsec: Function ====%%%
\subsection{Function}
\begin{quote}\bf
``Types representing functions from inputs to outputs.''
\end{quote}

%%%%%== Subsubsec: Function I ==%%%%%
\subsubsection{Basic Function Usage}
\textbf{Simple Function:} Let's start with a basic function that adds two numbers. In Cryptol, the syntax for function definition is concise.
\begin{lstlisting}[style=cryptol]
add : Integer -> Integer -> Integer;
add x y = x + y;
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> add 4294967296 4294967296
8589934592
\end{lstlisting}
\vspace{16pt}
\textbf{Function with Bitwise Operation:} Functions in Cryptol commonly operate on bits and sequences of bits. Here's a function that performs a bitwise AND on two 8-bit sequences.
\begin{lstlisting}[style=cryptol]
andBits : [8] -> [8] -> [8];
andBits a b = zipWith (&&) a b;
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> andBits 0x0f 0xf0
0x00
\end{lstlisting}
\vspace{20pt}
%%%%%== Subsubsec: Function II ==%%%%%
\subsubsection{Intermediate Function Usage}
\textbf{Functions with Conditional Logic:} Cryptol functions can implement more complex logic, including conditionals.
\begin{lstlisting}[style=cryptol]
max : Integer -> Integer -> Integer
max x y = if x > y then x else y
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> max 51 94
94
\end{lstlisting}

\begin{lstlisting}[style=cryptol]
property max_ge_x (x : Integer, y : Integer) = max x y >= x

property max_ge_y (x : Integer, y : Integer) = max x y >= y

property max_is_either (x : Integer, y : Integer) =
	(max x y == x) || (max x y == y)
\end{lstlisting}
\vspace{16pt}
\textbf{Recursive Functions:} Cryptol supports recursive functions, which can be powerful for certain types of algorithms.
\begin{lstlisting}[style=cryptol]
factorial : Integer -> Integer;
factorial n = if n == 0 then 1 else n * factorial (n - 1);
\end{lstlisting}
\begin{lstlisting}[style=zsh]
Main> factorial 10
3628800
\end{lstlisting}

\newpage
%%%%%== Subsubsec: Function III ==%%%%%
\subsubsection{Advanced Cryptographic Function Usage}
\textbf{Encrypting with XOR (One-Time Pad):} Here’s how you might define a simple encryption function using XOR, which is a foundational operation in many cryptographic systems..
\begin{lstlisting}[style=cryptol]
xorEncrypt : [8] -> [8] -> [8];
xorEncrypt key plaintext = zipWith (^) plaintext key;

property Reversibility (key : [8], plaintext : [8]) = 
	xorEncrypt key (xorEncrypt key plaintext) == plaintext
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> :prove
:prove Reversibility
	Q.E.D.
(Total Elapsed Time: 0.012s, using Z3)
\end{lstlisting}

%%%==== Subsec: Type Variables ====%%%
\subsection{Type Variables}

%%%%%== Subsubsec: Type Variables I ==%%%%%
\subsubsection{Basic Usage of Type Variables}
\textbf{Generic Identity Function:} A simple example of a type variable in use is the identity function, which returns whatever value is passed to it, regardless of type.
\begin{lstlisting}[style=cryptol]
id : {a} a -> a;
id x = x;
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> id 0xff
0xff
$ Main> id 0xffff
0xffff
\end{lstlisting}
\vspace{16pt}
\textbf{Generic Swap Function:} This function swaps the elements of a 2-tuple, and works for any types contained in the tuple.
\begin{lstlisting}[style=cryptol]
swap : {a, b} (a, b) -> (b, a)
swap (x, y) = (y, x)

mixedPair : (Integer, [8])
mixedPair = (42, 0xaa)

swappedMixedPair : ([8], Integer)
swappedMixedPair = swap mixedPair
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> mixedPair
(42, 0xaa)
$ Main> swappedMixedPairnewp
(0xaa, 42)
\end{lstlisting}

\newpage
%%%%%== Subsubsec: Type Variables II ==%%%%%
\subsubsection{Intermediate Usage of Type Variables}
\textbf{Generic Arrays:} You can define functions that operate on arrays of any type. This is useful for functions that perform operations like reversing an array.
\begin{lstlisting}[style=cryptol]
id : {a} a -> a
id x = x
\end{lstlisting}
\begin{lstlisting}[style=zsh]
$ Main> id 0xff
0xff
$ Main> id 0xffff
0xffff
\end{lstlisting}



\newpage
\iffalse
%Creating an effective curriculum and table of contents to study Cryptol, focusing on cryptographic verification and formal proofs, requires a structured approach that builds foundational knowledge before advancing to more complex topics. Here's a structured curriculum with a table of contents designed to facilitate quick and efficient learning:
%
%Curriculum for Cryptol: Cryptographic Verification Tool
%
%Objective: To gain a comprehensive understanding of Cryptol for cryptographic verification, focusing on formal proofs and practical applications.
%
%Duration: 8 Weeks (suggested pace of 10-12 hours per week)
%
%Week 1: 
\section{Introduction to Cryptography and Formal Methods}
%
%Introduction to Cryptography
%Basic concepts and terminologies
%Historical perspective and importance
%Introduction to Formal Methods
%What are formal methods?
%Importance in cryptography
%Overview of Cryptol
%History and development
%Cryptol's place in cryptographic research and industry
\section*{Overview}
This week provides an introduction to the fundamental concepts of cryptography and formal methods. It sets the foundation required for understanding and utilizing Cryptol, a language specifically designed for creating and analyzing cryptographic algorithms.

\subsection{Introduction to Cryptography}
\begin{enumerate}
	\item Basic concepts and terminologies:
	\begin{itemize}
		\item Definition of cryptography and its role in security.
		\item Understanding encryption, decryption, keys, and algorithms.
	\end{itemize}
	\item Historical perspective and importance:
	\begin{itemize}
		\item The evolution of cryptographic techniques.
		\item Real-world applications and implications of cryptography.
	\end{itemize}
\end{enumerate}

\subsection{Introduction to Formal Methods}
\begin{enumerate}
	\item What are formal methods?
	\begin{itemize}
		\item Definition and scope of formal methods in computer science.
		\item The significance of formal methods in developing secure systems.
	\end{itemize}
	\item Importance in cryptography:
	\begin{itemize}
		\item The role of formal methods in verifying cryptographic protocols and algorithms.
		\item Examples of formal methods applied in cryptography.
	\end{itemize}
\end{enumerate}

\subsection{Overview of Cryptol}
\begin{enumerate}
	\item History and development:
	\begin{itemize}
		\item The origins of Cryptol and its development history.
		\item Key features and capabilities of Cryptol.
	\end{itemize}
	\item Cryptol's place in cryptographic research and industry:
	\begin{itemize}
		\item Applications of Cryptol in industry and academia.
		\item Comparison with other cryptographic tools and languages.
	\end{itemize}
\end{enumerate}

\newpage
\section{Getting Started with Cryptol}
This section provides a comprehensive guide for setting up the Cryptol environment on your computer. It covers the installation process for different operating systems and introduces basic commands and operations essential for working with Cryptol.
\subsection{Installation and Setup}
\begin{enumerate}
\item \textbf{Windows:}
\begin{itemize}
	\item Download the latest Cryptol release from the official GitHub page \\
	(\url{https://github.com/GaloisInc/cryptol/releases}).
	\item Extract the downloaded ZIP file to your preferred location.
	\item Add the extracted Cryptol directory to your system's environment variables:
	\begin{enumerate}
		\item Right-click on 'This PC' and select 'Properties'.
		\item Click on 'Advanced system settings' and then 'Environment Variables'.
		\item Under 'System Variables', find 'Path', and click 'Edit'.
		\item Click 'New' and add the path to the extracted Cryptol folder.
		\item Click 'OK' to close all dialogues.
	\end{enumerate}
	\item Open Command Prompt and type \texttt{cryptol} to start the Cryptol REPL.
\end{itemize}
\item \textbf{macOS:}
\begin{itemize}
\item Install Homebrew if it is not already installed, using the command
\begin{lstlisting}[style=zsh]
/bin/bash -c
"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
\end{lstlisting}
%\texttt{/bin/bash -c "\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"}.
\item Install Cryptol using Homebrew by executing `\texttt{brew install cryptol}'.
\item Verify the installation by opening a terminal and typing `\texttt{cryptol}'.
\end{itemize}
\item \textbf{Linux:}
\begin{itemize}
\item For Debian-based distributions, you can install Cryptol using the following commands:
\begin{lstlisting}[style=zsh]
@:~$ sudo apt-get update
@:~$ sudo apt-get install cryptol
\end{lstlisting}
\item For other distributions, download the appropriate binaries from the Cryptol GitHub releases page and follow similar steps as for Windows.
\item Verify the installation by opening a terminal and typing `\texttt{cryptol}'.
\end{itemize}
\end{enumerate}
Setting up the working environment for Cryptol coding and testing:
\begin{itemize}
	\item Choose a text editor or IDE that you are comfortable with for writing Cryptol scripts. Popular options include Visual Studio Code, Emacs, and Vim.
	\item Install any necessary plugins or extensions for your chosen editor that support Cryptol syntax highlighting and code completion.
	\item Create a dedicated workspace or directory for your Cryptol projects to keep your files organized.
\end{itemize}

\newpage
\section{Basic Syntax and Types in Cryptol}

\url{https://www.youtube.com/watch?v=sC2_5WaavFc}
\subsection{Data Types, Functions, and Modules}
This subsection delves into the core elements of Cryptol's programming model: its type system, functions, and module system. Understanding these elements is crucial for effective Cryptol programming, particularly for cryptographic applications.

\subsubsection{Understanding Cryptol's Type System}
Cryptol's type system is designed to provide a high degree of safety and expressiveness, especially important in the context of cryptographic applications where precision is paramount.

\begin{enumerate}
	\item \textbf{Bits and Sequences:}
	\begin{itemize}
		\item Cryptol's basic type is the Bit, representing a single binary digit, which can be either \texttt{True} (1) or \texttt{False} (0).
		\item Sequences are ordered collections of elements of the same type. In Cryptol, sequences are used to represent strings of bits (binary data), which are fundamental in cryptography.
		\item A sequence of bits is declared as \texttt{[n]Bit}, where \texttt{n} specifies the sequence length. For example, \texttt{[8]Bit} represents a byte.
		\item Cryptol supports sequence manipulations such as indexing, slicing, and concatenation, crucial for various cryptographic operations.
	\end{itemize}
	
	\item \textbf{Functions:}
	\begin{itemize}
		\item Functions in Cryptol are first-class citizens, meaning they can be passed as arguments, returned from other functions, and stored in variables.
		\item A function's type signature is defined by its input and output types. For example, a function taking two bytes and returning a byte has the type \texttt{[8]Bit -> [8]Bit -> [8]Bit}.
		\item Cryptol functions support pattern matching, guards, and recursion, providing a powerful toolset for defining complex cryptographic transformations.
	\end{itemize}
\end{enumerate}

\subsubsection{Defining and Using Modules in Cryptol}
Modules in Cryptol help organize code into reusable and maintainable units, similar to modules or packages in other programming languages.

\begin{enumerate}
	\item \textbf{Module Definition:}
	\begin{itemize}
		\item A module in Cryptol is defined using the \texttt{module} keyword, followed by the module name and the module body enclosed in braces.
		\item Inside a module, you can define types, functions, and constants. Modules can also include other modules.
		\item Example:
		\begin{verbatim}
			module MyModule where
			// Module contents go here
			myFunction : [8]Bit -> [8]Bit
			myFunction x = x ^ 0xFF
		\end{verbatim}
		This defines a module named \texttt{MyModule} containing a function \texttt{myFunction} that performs a bitwise XOR with the byte value 0xFF.
	\end{itemize}
	
	\item \textbf{Using Modules:}
	\begin{itemize}
		\item To use a module in Cryptol, you can import it using the \texttt{import} statement at the beginning of your Cryptol script or within another module.
		\item Once imported, you can access the functions, types, and constants defined in the module.
		\item Example:
		\begin{verbatim}
			import MyModule
			result = myFunction 0xAB
		\end{verbatim}
		This imports \texttt{MyModule} and uses \texttt{myFunction} to compute the XOR of 0xAB and 0xFF.
	\end{itemize}
\end{enumerate}

The concepts of data types, functions, and modules are fundamental to programming in Cryptol. By mastering these, you will be well-equipped to tackle more advanced cryptographic programming challenges in Cryptol.

\subsection{Type System and Type Inference}

Cryptol's type system is one of its most powerful features, ensuring that operations are applied correctly and preventing a wide range of programming errors. Understanding the principles behind this type system and how type inference operates within it is crucial for effective Cryptol programming.

\subsubsection{Principles Behind Cryptol's Strong Type System}
Cryptol's type system is designed with the security and reliability needs of cryptographic algorithms in mind. Here are some of the foundational principles:

\begin{itemize}
	\item \textbf{Strong Typing:} Every value in Cryptol has a type, and all types are checked at compile time. This eliminates a vast array of bugs related to type mismatches.
	\item \textbf{Rich Type Constructs:} Cryptol supports a variety of types beyond the basics, including fixed-size sequences, which are particularly useful in cryptography for representing data like keys and blocks.
	\item \textbf{Parametric Polymorphism:} This allows functions to operate on different types without changing the function's code, similar to generics in other programming languages.
	\item \textbf{Type Synonyms:} Cryptol allows the creation of new names for types, enhancing code readability and maintainability.
	\item \textbf{Type Classes:} These are similar to interfaces in other languages, defining a set of operations that a type must support.
\end{itemize}

Understanding these principles is vital as they inform the structure and capabilities of Cryptol’s type system, allowing it to support complex, high-assurance cryptographic specifications with clarity and precision.

\subsubsection{How Type Inference Simplifies Code in Cryptol}
Type inference in Cryptol refers to the compiler's ability to automatically deduce the types of expressions without explicit type annotations from the programmer. This feature significantly simplifies code in several ways:

\begin{itemize}
	\item \textbf{Less Boilerplate:} Programmers do not need to annotate every expression with a type, leading to clearer and more concise code.
	\item \textbf{Code Flexibility:} Functions can automatically work with different types (as long as they make sense in context), reducing the need for multiple versions of the same function.
	\item \textbf{Error Detection:} The compiler uses type inference to detect inconsistencies and potential bugs without needing exhaustive type specifications from the programmer.
	\item \textbf{Generality:} Inferred types are often more general than what a programmer might specify, allowing for more reusable and abstract code.
\end{itemize}

However, while type inference simplifies code, understanding how types are determined is important for debugging and for writing correct, secure cryptographic algorithms. In some cases, explicitly stating types can clarify intentions and ensure that the compiler's type deductions align with the programmer’s expectations.

In practice, balancing the use of type inference with explicit type annotations can lead to code that is both concise and clear. It allows Cryptol to serve as an effective tool for implementing and verifying cryptographic algorithms, leveraging its strong type system to ensure correctness and security.

\subsection{Type System and Type Inference}

Cryptol's type system is integral for ensuring the safety and correctness of cryptographic code. Below, we delve into the principles of Cryptol's type system and demonstrate how type inference simplifies coding through specific examples.

\subsubsection{Principles Behind Cryptol's Strong Type System}
Cryptol's type system is meticulously designed to cater to cryptographic needs, ensuring operations are correctly applied and eliminating common programming errors. The following principles underpin Cryptol's type system:

\begin{itemize}
	\item \textbf{Strong Typing:} In Cryptol, every value is associated with a type, which is determined at compile time. This strict approach helps to prevent errors related to incorrect type usage.
	\item \textbf{Rich Type Constructs:} Cryptol supports types like fixed-size sequences, crucial for representing cryptographic data such as keys and message blocks.
	\item \textbf{Parametric Polymorphism:} Functions in Cryptol can be written to work with any type, enhancing code reusability and flexibility.
	\item \textbf{Type Synonyms and Type Classes:} Cryptol allows for the creation of new names for existing types and the definition of type classes, facilitating clearer and more maintainable code.
\end{itemize}

For example, consider the type signature for a function that performs an exclusive or (XOR) on two bit sequences:

\begin{verbatim}
	xor : {n} (fin n) => [n] -> [n] -> [n]
\end{verbatim}

This signature indicates that `xor` is a function that takes two sequences of bits of the same length `n` and returns a new sequence of bits of the same length. The `{n}` syntax indicates that `n` is a parameter to the type, and `(fin n)` ensures that `n` is finite, which is necessary for the operation to make sense in the context of fixed-size sequences.

\subsubsection{How Type Inference Simplifies Code in Cryptol}
Type inference in Cryptol reduces the need for explicit type annotations, allowing the compiler to deduce types automatically. This simplification can be illustrated through practical examples:

\begin{itemize}
	\item \textbf{Less Boilerplate:} Without type inference, every variable and expression would need an explicit type, making the code verbose and harder to read. With type inference, many of these annotations are unnecessary. For instance, when defining a new variable, `a = 5`, Cryptol automatically understands `a` to be of type `Integer`.
	
	\item \textbf{Code Flexibility:} A function written without specific type annotations can operate over different types. For example, the function `inc x = x + 1` can be used to increment an integer, a floating-point number, or even a sequence of numbers, without defining separate functions for each type.
	
	\item \textbf{Error Detection:} Type inference helps detect inconsistencies in code. If you attempt to use a sequence where a number is expected, Cryptol's type system flags an error, preventing potential bugs.
	
	\item \textbf{Generality:} By inferring the most general type possible, Cryptol makes functions more reusable. Consider a function `f x y = x \&\& y`. Without specifying types, Cryptol infers the most general form, allowing `f` to be applied to any two arguments of the same type that supports the `\&\&` operation.
\end{itemize}

To solidify understanding, let's look at a specific example illustrating type inference:

\begin{verbatim}
	let add a b = a + b
\end{verbatim}

In this case, Cryptol infers that `a` and `b` must be of a type that supports addition. If `add` is used with two integers, Cryptol infers the type of `a` and `b` as `Integer`. If it is used with two sequences of bits, it infers their types accordingly, showcasing the power and flexibility of type inference in making code more concise and versatile.

By leveraging these examples, it becomes evident how Cryptol's type system and type inference mechanism work hand in hand to ensure that cryptographic algorithms are both secure and correct, while also being concise and readable.

\newpage
\begin{enumerate}
	\item Basic commands and operations:
	\begin{itemize}
		\item Introduction to the Cryptol command line interface:
		\begin{itemize}
			\item The Cryptol command line interface (CLI) allows you to interact with Cryptol directly from your terminal or command prompt.
			\item You can enter the interactive mode by simply typing \texttt{cryptol} without any arguments. In this mode, you can type Cryptol expressions and commands directly and see their results.
			\item Exit the interactive mode by typing \texttt{:q} or pressing Ctrl-D.
		\end{itemize}
		\item Common commands for interpreting and compiling Cryptol scripts:
		\begin{itemize}
			\item To load a Cryptol script from the CLI, use the \texttt{:load} command or its shorthand \texttt{:l}, followed by the file name, e.g., \texttt{:load MyScript.cry}.
			\item To check the type of an expression, use the \texttt{:type} command or its shorthand \texttt{:t}, followed by the expression, e.g., \texttt{:type [1..10]}.
			\item To evaluate an expression or execute a function, simply type it into the CLI and press Enter.
			\item Use the \texttt{:help} command to display a list of all available commands and their descriptions.
		\end{itemize}
	\end{itemize}
\end{enumerate}
\begin{enumerate}
	\item Environment setup:
	\begin{itemize}
		\item Instructions for installing Cryptol on various operating systems.
		\item Setting up the working environment for Cryptol coding and testing.
	\end{itemize}
	\item Basic commands and operations:
	\begin{itemize}
		\item Introduction to the Cryptol command line interface.
		\item Common commands for interpreting and compiling Cryptol scripts.
	\end{itemize}
\end{enumerate}

\subsection{Basic Commands and Operations}
Once Cryptol is installed, you can start using it through the command line interface (CLI). Here are some basic commands to get you started:

\begin{enumerate}
	\item \textbf{Starting the Cryptol REPL:} 
	\begin{itemize}
		\item Open your command line interface (Command Prompt, Terminal, etc.).
		\item Type \texttt{cryptol} and press Enter to start the Cryptol Read-Eval-Print Loop (REPL).
		\item You should see the Cryptol version number and a welcome message.
	\end{itemize}
	
	\item \textbf{Loading Cryptol modules:}
	\begin{itemize}
		\item In the REPL, use the \texttt{:load} command (or \texttt{:l} for short) followed by the filename to load a Cryptol module, e.g., \texttt{:load MyModule.cry}.
		\item Once loaded, you can access the functions defined within the module.
	\end{itemize}
	
	\item \textbf{Interpreting Cryptol scripts:}
	\begin{itemize}
		\item You can interpret individual commands directly in the REPL by typing them and pressing Enter.
		\item For example, to define a new function, simply type the function definition and press Enter.
		\item Use the \texttt{:?} command to display a list of all available commands within the REPL.
	\end{itemize}
	
	\item \textbf{Exiting the REPL:}
	\begin{itemize}
		\item To exit the REPL, type \texttt{:quit} or \texttt{:q} and press Enter.
		\item Alternatively, you can press Ctrl+D (EOF) on Linux and macOS or Ctrl+Z followed by Enter on Windows.
	\end{itemize}
\end{enumerate}

By following these steps and familiarizing yourself with the basic commands, you will be well-prepared to begin exploring the vast capabilities of Cryptol for cryptographic verification and formal proofs.

\newpage
\subsection{Basic Syntax and Types in Cryptol}
\begin{enumerate}
	\item Data types, functions, and modules:
	\begin{itemize}
		\item Understanding Cryptol's type system - bits, sequences, and functions.
		\item How to define and use modules in Cryptol.
	\end{itemize}
	\item Type system and type inference:
	\begin{itemize}
		\item The principles behind Cryptol's strong type system.
		\item How type inference simplifies code in Cryptol.
	\end{itemize}
\end{enumerate}

\subsection{First Cryptol Programs}
\begin{enumerate}
	\item Writing and testing simple programs:
	\begin{itemize}
		\item Creating basic Cryptol scripts and functions.
		\item Running and testing Cryptol code for correctness.
	\end{itemize}
	\item Understanding Cryptol's REPL (Read-Eval-Print Loop):
	\begin{itemize}
		\item Interactive mode vs. script mode in Cryptol.
		\item Practical exercises to reinforce learning and understanding.
	\end{itemize}
\end{enumerate}

%Week 2: Getting Started with Cryptol
%
%Installation and Setup
%Environment setup
%Basic commands and operations
%Basic Syntax and Types in Cryptol
%Data types, functions, and modules
%Type system and type inference
%First Cryptol Programs
%Writing and testing simple programs
%Understanding Cryptol's REPL (Read-Eval-Print Loop)
%Week 3: Functions and Advanced Data Types in Cryptol
%
%Detailed Function Definition and Recursion
%Creating complex functions
%Recursive functions in Cryptol
%Advanced Data Types
%Sequences, arrays, and records
%Manipulating complex data structures
%Week 4: Cryptographic Algorithms in Cryptol
%
%Symmetric Key Cryptography
%Implementing basic block ciphers
%Cryptanalysis techniques and testing
%Asymmetric Key Cryptography
%Basics of public key algorithms
%Implementing and testing simple schemes
%Week 5: Formal Verification Concepts
%
%Introduction to Formal Verification
%The concept of proof in cryptography
%Automated theorem proving
%Using Cryptol for Formal Verification
%Writing specifications and properties
%Proving properties about cryptographic algorithms
%Week 6: Advanced Cryptographic Techniques and Protocols
%
%Hash Functions and Message Authentication Codes
%Implementing and verifying properties
%Advanced Encryption Schemes
%Modes of operation and implementation challenges
%Cryptographic Protocols
%Key exchange protocols and authentication
%Week 7: Real-World Applications and Case Studies
%
%Analyzing Real-World Cryptographic Systems
%Case studies of cryptographic failures and successes
%Implementing and Verifying Protocols in Cryptol
%Practical challenges and solutions in verification
%Performance Optimization
%Efficient Cryptol coding practices
%Optimization techniques for cryptographic algorithms
%Week 8: Capstone Project and Further Learning
%
%Capstone Project
%Selecting a project relevant to your interests or field
%Implementing and verifying a cryptographic system or protocol
%Further Learning and Resources
%Advanced topics in cryptography and formal verification
%Continuing education and community involvement
%Additional Resources:
%
%Official Cryptol Documentation and Tutorials
%Research Papers and Articles on Cryptography and Formal Methods
%Online Forums and Community Discussions
\fi