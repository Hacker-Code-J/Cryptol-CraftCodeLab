module HIGHT_SPEC where

// Define types for clarity
type State = [8][8]  // 8-byte state
type Key = [16][8]   // 16-byte master key
type RoundKeys = [128][8] // 128-byte subkey array
type WhiteningKeys = [8][8] // 8-byte whitening key array

delta_table : [128][8]
delta_table = [ 
    0x5a, 0x6d, 0x36, 0x1b, 0x0d, 0x06, 0x03, 0x41, // 0 ~ 7
    0x60, 0x30, 0x18, 0x4c, 0x66, 0x33, 0x59, 0x2c, // 8 ~ 15
    0x56, 0x2b, 0x15, 0x4a, 0x65, 0x72, 0x39, 0x1c, // 16 ~ 23 
    0x4e, 0x67, 0x73, 0x79, 0x3c, 0x5e, 0x6f, 0x37, // 24 ~ 31 
    0x5b, 0x2d, 0x16, 0x0b, 0x05, 0x42, 0x21, 0x50, // 32 ~ 39 
    0x28, 0x54, 0x2a, 0x55, 0x6a, 0x75, 0x7a, 0x7d, // 40 ~ 47 
    0x3e, 0x5f, 0x2f, 0x17, 0x4b, 0x25, 0x52, 0x29, // 48 ~ 55 
    0x14, 0x0a, 0x45, 0x62, 0x31, 0x58, 0x6c, 0x76, // 56 ~ 63 
    0x3b, 0x1d, 0x0e, 0x47, 0x63, 0x71, 0x78, 0x7c, // 64 ~ 71 
    0x7e, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x43, 0x61, // 72 ~ 79 
    0x70, 0x38, 0x5c, 0x6e, 0x77, 0x7b, 0x3d, 0x1e, // 80 ~ 87 
    0x4f, 0x27, 0x53, 0x69, 0x34, 0x1a, 0x4d, 0x26, // 88 ~ 95 
    0x13, 0x49, 0x24, 0x12, 0x09, 0x04, 0x02, 0x01, // 96 ~ 103 
    0x40, 0x20, 0x10, 0x08, 0x44, 0x22, 0x11, 0x48, // 104 ~ 111 
    0x64, 0x32, 0x19, 0x0c, 0x46, 0x23, 0x51, 0x68, // 112 ~ 119 
    0x74, 0x3a, 0x5d, 0x2e, 0x57, 0x6b, 0x35, 0x5a  // 120 ~ 127
 ]

// Function to split a n-byte array into two (n/2)-byte blocks
splitToHalf : [16][8] -> ([8][8], [8][8])
splitToHalf bytes = (take`{8} bytes, drop`{8} bytes)

// Function to combine two 8-byte blocks into a single 16-byte array
combineBlocks : ([8][8], [8][8]) -> [16][8]
combineBlocks (a, b) = a # b

// // Function to rotate one byte to the left for an 8-byte block
// rotateLeft8 : [8][8] -> [8][8]
// rotateLeft8 block = drop`{1} block # take`{1} block

// // Function to perform <<<1 operation by dividing a [16][8] array in half
// rotateLeft16 : [16][8] -> [16][8]
// rotateLeft16 bytes = join (rotateLeft8 a # rotateLeft8 b)
//   where
//     (a, b) = splitInHalf bytes

// // Example usage
// exampleBytes : [16][8]
// exampleBytes = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
//                 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F]

// Function to rotate the second half of the key once to the left
rotateLeft8 : [8][8] -> [8][8]
rotateLeft8 block = drop`{1} block # take`{1} block

rotateRight8 : [8][8] -> [8][8]
rotateRight8 block = drop`{7} block # take`{7} block

updateMK : [16][8] -> [16][8]
updateMK mk = rotatedMK
    where
    (firstHalf, secondHalf) = splitAt`{8} mk
    rotatedFirstHalf = rotateRight8 firstHalf
    rotatedSecondHalf = rotateRight8 secondHalf
    rotatedMK = rotatedFirstHalf # rotatedSecondHalf

// Define the encKeySchedule function
encKeySchedule : ([8][8], [128][8], [16][8]) -> ([8][8], [128][8])
encKeySchedule (enc_WK, enc_SK, MK) = (enc_WK', enc_SK')
  where
    // Generate whitening keys
    enc_WK' = [
      MK@12, MK@13, MK@14, MK@15,
      MK@0, MK@1, MK@2, MK@3
    ]

    enc_SK' = [ subkey i | i <- [0..127] ]
  where
    subkey i = 
      if i < 16
      then MK @ i + delta_table @ i
      else if i < 32
      then (updateMK MK) @ (i - 16) 
            + delta_table @ i
      else if i < 48
      then (updateMK (updateMK MK)) @ ((i - 32)) 
            + delta_table @ i
      else if i < 64
      then (updateMK (updateMK (updateMK MK))) @ (i - 48)
            + delta_table @ i
      else if i < 80
      then (updateMK (updateMK (updateMK (updateMK MK)))) @ (i - 64)
            + delta_table @ i
      else if i < 96
      then (updateMK (updateMK (updateMK (updateMK (updateMK MK))))) @ (i - 80) 
            + delta_table @ i
      else if i < 112
      then (updateMK (updateMK (updateMK (updateMK (updateMK (updateMK MK)))))) @ (i - 96) 
            + delta_table @ i
      else
           (updateMK (updateMK (updateMK (updateMK (updateMK (updateMK (updateMK MK))))))) @ (i - 112) 
            + delta_table @ i

F0 : [8] -> [8]
F0 byte = (byte <<< 1) ^ (byte <<< 2) ^ (byte <<< 7)

F1 : [8] -> [8]
F1 byte = (byte <<< 3) ^ (byte <<< 4) ^ (byte <<< 6)

// Initial state modification based on whitening keys
initialStateModification : State -> WhiteningKeys -> State
initialStateModification state WK =
    [ state @ 0 + WK @ 0
    , state @ 1
    , state @ 2 ^ WK @ 1
    , state @ 3
    , state @ 4 + WK @ 2
    , state @ 5
    , state @ 6 ^ WK @ 3
    , state @ 7 ]

// State update function for a single iteration
updateState : ([8][8], [128][8], [8]) -> [8][8]
updateState (state, SK, i) =
    [ state @ 7 ^ (F0 (state @ 6) + SK @ (i * 4 + 3))
    , state @ 0
    , state @ 1 + (F1 (state @ 0) ^ SK @ (i * 4 + 0))
    , state @ 2
    , state @ 3 ^ (F0 (state @ 2) + SK @ (i * 4 + 1))
    , state @ 4
    , state @ 5 + (F1 (state @ 4) ^ SK @ (i * 4 + 2))
    , state @ 6 ]

// Final state modification based on whitening keys
finalStateModification : State -> WhiteningKeys -> State
finalStateModification state WK =
    [ state @ 0 + WK @ 4
    , state @ 1
    , state @ 2 ^ WK @ 5
    , state @ 3
    , state @ 4 + WK @ 6
    , state @ 5
    , state @ 6 ^ WK @ 7
    , state @ 7 ]

// HIGHT encryption function
HIGHT_Encrypt : [8][8] -> [8][8] -> [16][8] -> [8][8]
HIGHT_Encrypt dst src MK = finalState
  where
    // Generate whitening keys and round keys from master key
    (WK, SK) = encKeySchedule(zero, zero, MK)


    // Initial state modification
    state1 = initialStateModification src WK

    // Iterate state update function 31 times (0 to 30)
    state2 = foldl (\s i -> updateState (s, SK, i)) state1 [0..7]
    // state2_2 = foldl (\s i -> updateState (s, SK, i)) state2_1 [8..8]

    finalState = state2

    // Final state modification before final round keys
    // state3 = [ state2 @ 0
    //          , state2 @ 1 + (F1 (state2 @ 0) ^ SK @ 124)
    //          , state2 @ 2
    //          , state2 @ 3 ^ (F0 (state2 @ 2) + SK @ 125)
    //          , state2 @ 4
    //          , state2 @ 5 + (F1 (state2 @ 4) ^ SK @ 126)
    //          , state2 @ 6
    //          , state2 @ 7 ^ (F0 (state2 @ 6) + SK @ 127) ]

    // // Final state modification
    // finalState = finalStateModification state3 WK

// Define the given hexadecimal string as a bit sequence
key : [128]
key = 0x28dbc3bc49ffd87dcfa509b11d422be7
pt : [64]
pt = 0xb41e6be2eba84a14
ct : [64]
ct = 0xcc047a75209c1fc6


splitKey : [16][8]
splitKey = reverse (split (key : [128]))
splitPT : [8][8]
splitPT = reverse (split (pt : [64]))

// splitTmp : [8][8]
// splitTmp = reverse (split (tmp : [64]))
splitCT : [8][8]
splitCT = reverse (split (ct : [64]))

// property TESTVECTOR4 =
//   HIGHT_Encrypt zero splitPT splitKey == splitCT